<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>Attention</title>
<style>
  :root{
    --bg:#FFB6C1;               /* background behind fixed launch layer */
    --btn:#FFD700;              /* standard button */
    --btn-primary:#90EE90;      /* primary Start style (mirrors reference emphasis) */
    --text:#222;
    --good:#1f9d55;             /* green */
    --bad:#e3342f;              /* red */
    --card-rgb:255,253,253;     /* warm translucent card, as in emotions.html */
    --shadow: 0 10px 20px rgba(0,0,0,0.12);
    --shadow-soft: 0 12px 24px rgba(0,0,0,0.14);
    --focus:#000;               /* visible focus ring */
  }
  html,body{
    margin:0; padding:0; height:100%; background:var(--bg); color:var(--text);
    font-family: "Comic Neue", system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, "Noto Sans", "Liberation Sans", sans-serif;
  }

  /* Screen visibility controller (DO NOT change) */
  .screen{ display:none; height:100%; width:100%; position:relative; }
  .screen.active{ display:block; }

  /* Launch section: fixed, full-bleed bg like emotions.html */
  #start {
    position: fixed;           /* full viewport */
    inset: 0;
    width: 100vw;
    height: 100vh;
    overflow: hidden;
    /* IMPORTANT: do NOT force display here; let .screen/.active control it */
  }
  #start::before{
    content:"";
    position:fixed;
    inset:0;
    background: url("assets/attention/images/ui/bg-launch.png") center/cover no-repeat;
    z-index:0;
  }

  /* Launch intro card — mirror attention-2.html sizing/feel */
  .center-card{
    position:absolute; inset:0; margin:auto;
    width: min(720px, 92vw);   /* MATCH reference size */
    max-height: 90vh;          /* Scrolls if content grows */
    overflow: auto;
    background: rgba(255,253,253,0.85); /* warm translucent */
    border-radius: 18px;        /* MATCH reference radius */
    box-shadow: 0 12px 30px rgba(0,0,0,0.20); /* slightly deeper */
    padding: 20px;              /* tighter padding like reference */
    z-index: 1;
    text-align: center;
    backdrop-filter: saturate(120%) blur(1px);
  }

  /* Unit pill as overline */
  .unit-pill{
    display:inline-block;
    background:#fcba03;
    color:#000;
    padding:6px 12px;
    border-radius:999px;
    font-weight:700;
    font-size:clamp(14px, 1.8vw, 16px);
    border:2px solid #222;
    margin-bottom:6px;
  }

  /* Title + body typography (compact, bold title) */
  h1{ margin:8px 0 6px; font-weight:800; font-size:clamp(28px, 4vw, 42px); line-height:1.12; }
  p{ line-height:1.4; font-size:clamp(16px, 2.2vw, 18px); margin:8px 0; }

  /* Buttons row */
  .btn-row{ display:flex; gap:12px; flex-wrap:wrap; margin-top:14px; align-items:center; justify-content:center; }

  /* Base button / anchor-as-button styles */
  .btn, .btn.nav{
    background:var(--btn); color:var(--text); border:none; border-radius:14px;
    padding:12px 18px; font-weight:700; font-size:16px; cursor:pointer;
    box-shadow: var(--shadow);
    transition: transform .15s ease, filter .2s ease;
    text-decoration:none; /* make anchors look like buttons */
    display:inline-block;
  }
  /* Primary emphasis (Start) */
  .btn--primary{ background: var(--btn-primary); }

  .btn:hover, .btn.nav:hover{ transform: translateY(-1px) scale(0.99); filter:brightness(0.98); }
  .btn:active, .btn.nav:active{ transform: translateY(0) scale(0.97); }

  /* Visible keyboard focus per Navigation Standard (3–4 px) */
  .btn.nav:focus, a.btn:focus, .btn:focus{
    outline:4px solid var(--focus); outline-offset:2px;
  }

  /* Utility: hidden (for collapsible panel) */
  .hidden{ display:none !important; }

  /* Keep legacy controls wired but hidden from layout/AT */
  .visually-hidden{
    position:absolute !important; width:1px !important; height:1px !important;
    padding:0 !important; margin:-1px !important; overflow:hidden !important;
    clip:rect(0,0,0,0) !important; white-space:nowrap !important; border:0 !important;
  }

  /* Game HUD */
  .hud{
    position:absolute; top:8px; left:8px; right:8px; display:flex; justify-content:space-between; align-items:center; gap:8px;
    z-index:50;
  }
  .hud-pill{
    background:rgba(255,255,255,0.9); padding:8px 12px; border-radius:999px; box-shadow:var(--shadow);
    font-weight:700; min-width:90px; text-align:center;
  }
  .hud a.home-link{ text-decoration:none; color:var(--text); }
  .hud .title{ font-weight:800; }

  /* Playfield */
  .play-area{
    position:absolute; inset:0; overflow:hidden; border-radius:18px;
    background-size:cover; background-position:center;
  }

  /* Sprites */
  .sprite{
    position:absolute; width:100px; height:100px; user-select:none; -webkit-user-drag:none; cursor:pointer;
    transition: transform 0.15s ease;
  }
  .sprite:active{ transform: scale(0.95); }

  /* Feedback */
  .feedback{
    position:absolute; left:50%; transform:translateX(-50%);
    bottom:30px; font-weight:900; font-size:28px; pointer-events:none; z-index:60;
    opacity:0;
  }
  .feedback.show{ opacity:1; animation: fadeUp .6s ease; }
  .feedback.good{ color:var(--good); }
  .feedback.bad{ color:var(--bad); }

  @keyframes fadeUp{
    0%{ transform:translateX(-50%) translateY(8px); opacity:0;}
    20%{ opacity:1;}
    100%{ transform:translateX(-50%) translateY(-6px); opacity:0;}
  }

  .shake{ animation: shake .35s linear; }
  @keyframes shake{
    0%{ transform:translateX(0); }
    25%{ transform:translateX(-6px); }
    50%{ transform:translateX(6px); }
    75%{ transform:translateX(-4px); }
    100%{ transform:translateX(0); }
  }

  .fade-out{ animation: sprFade .8s ease forwards; }
  @keyframes sprFade{
    from{ opacity:1; }
    to{ opacity:0; transform: translateY(8px); }
  }

  .big-score{
    font-size: clamp(24px, 5vw, 36px);
    font-weight:900;
    margin: 10px 0 0;
  }
</style>
</head>
<body>

<!-- START / LAUNCH SCREEN -->
<section id="start" class="screen active" aria-label="Launch screen">
  <div class="center-card" role="dialog" aria-labelledby="launchTitle">
    <div class="unit-pill" aria-label="Unit title">Unit 3: Basics of Attention and Focus</div>
    <h1 id="launchTitle">Brain Spotlight</h1>
    <p>Tap only the <strong>positive</strong> items. Ignore the rest. You’ll have 30 seconds per level.</p>

    <!-- Controls: Start / How to Play / Return to the Park -->
    <div class="btn-row">
      <button class="btn btn--primary" id="launchStart">Start</button>
      <button class="btn" id="launchHowTo">How to Play</button>
      <a class="btn nav" id="launchHome" href="lesson-screen-htmls/lesson-03.01.html">Return to the Park</a>
    </div>

    <!-- Collapsible how-to panel (hidden by default) -->
    <div id="howToPanel" class="hidden" aria-live="polite">
      <ol style="margin:8px 0 0 18px; text-align:left;">
        <li>Look for items that match the <strong>positive</strong> target for this round.</li>
        <li>Tap only the positive items; ignore the rest.</li>
        <li>Watch the timer. Quick, accurate taps earn more points.</li>
        <li>Each new level changes the target (Behaviors → Emotions → Thoughts).</li>
      </ol>
    </div>

    <!-- Preserve original hidden buttons/IDs for JS wiring -->
    <div class="visually-hidden" aria-hidden="true">
      <button class="btn" id="btnStartProgressive">Start (Behaviors → Emotions → Thoughts)</button>
      <button class="btn" id="btnChaos">Bonus: Chaos Round (all mixed)</button>
      <a class="btn" id="legacyHome1" href="lesson-screen-htmls/lesson-03.01.html">Return to the Park</a>
    </div>

    <p style="opacity:.75; font-size:14px; margin-top:6px;">Images drift in and out. Keep your brain’s spotlight on the positives!</p>
  </div>
</section>

<!-- INSTRUCTION SCREEN -->
<section id="instruction" class="screen" aria-label="Instruction screen">
  <div class="center-card">
    <h1 id="instrTitle">Level 1: Behaviors</h1>
    <p id="instrText">Tap only the <strong>positive behaviors</strong>. Ignore the negative ones.</p>
    <div class="btn-row">
      <button class="btn btn--primary" id="btnBeginRound">Start Level</button>
      <a class="btn nav" href="lesson-screen-htmls/lesson-03.01.html">Return to the Park</a>
    </div>
  </div>
</section>

<!-- GAMEPLAY SCREEN -->
<section id="game" class="screen" aria-label="Gameplay screen">
  <div class="hud">
    <div class="hud-pill title" id="hudLevel">Behaviors</div>
    <div style="display:flex; gap:8px; align-items:center;">
      <div class="hud-pill" id="hudTimer">20s</div>
      <div class="hud-pill" id="hudScore">Score: 0</div>
      <a class="hud-pill home-link btn nav" href="lesson-screen-htmls/lesson-03.01.html">Return to the Park</a>
    </div>
  </div>
  <div id="playArea" class="play-area"></div>
  <div id="feedback" class="feedback">Nice!</div>
</section>

<!-- END SCREEN -->
<section id="end" class="screen" aria-label="End screen">
  <div class="center-card">
    <h1>Great focus!</h1>
    <p>Attention is like a spotlight in your brain — you can choose what to focus on!</p>
    <div class="big-score" id="finalScore">You scored 0 points.</div>
    <div class="btn-row" style="margin-top:16px;">
      <button class="btn btn--primary" id="btnPlayNext">Next</button>
      <button class="btn" id="btnReplay">Play Again</button>
      <a class="btn nav" href="lesson-screen-htmls/lesson-03.01.html">Return to the Park</a>
    </div>
  </div>
</section>

<script>
/* ---------------------------
   CONFIG (prototype-simple)
--------------------------- */
const ROUND_DURATION_MS = 20000;       // 20s (UI text mentions 30; adjust if needed elsewhere)
const SPRITE_SIZE = 120;
const ACTIVE_SPRITES = 5;
const SPRITE_LIFETIME_MS = 4500;
const GRID_ROWS = 3, GRID_COLS = 3;
const JITTER = 20;
const POSITIVE_SPAWN_RATIO = 0.5;

// Relative paths so file:// works locally
const AUDIO = {
  bgm: 'assets/audio/attention-bgm.mp3',
  tapGood: 'assets/audio/tap-correct.mp3',
  tapBad: 'assets/audio/tap-wrong.mp3'
};
const BG_IMAGE = 'assets/attention/background.png'; // optional
const ASSET_ROOT = 'assets/attention/';

// Level definitions
const LEVELS = [
  {
    key: 'behaviors',
    title: 'Level 1: Behaviors',
    hud: 'Behaviors',
    instruction: 'Tap only the positive behaviors. Ignore the negative ones.',
    positives: Array.from({length:4}, (_,i)=>`behaviors/behavior-pos-${i+1}.png`),
    negatives: Array.from({length:4}, (_,i)=>`behaviors/behavior-neg-${i+1}.png`),
  },
  {
    key: 'emotions',
    title: 'Level 2: Emotions',
    hud: 'Emotions',
    instruction: 'Tap only the positive emotions. Ignore the negative ones.',
    positives: Array.from({length:4}, (_,i)=>`emotions/emotion-pos-${i+1}.png`),
    negatives: Array.from({length:4}, (_,i)=>`emotions/emotion-neg-${i+1}.png`),
  },
  {
    key: 'thoughts',
    title: 'Level 3: Thoughts',
    hud: 'Thoughts',
    instruction: 'Tap only the positive thoughts. Ignore the negative ones.',
    positives: Array.from({length:4}, (_,i)=>`thoughts/thought-pos-${i+1}.png`),
    negatives: Array.from({length:4}, (_,i)=>`thoughts/thought-neg-${i+1}.png`),
  }
];

/* ---------------------------
   STATE
--------------------------- */
let mode = 'progressive'; // 'progressive' | 'chaos'
let levelIndex = 0;
let score = 0;
let roundStart = 0;
let rafId = null;
let timerId = null;
const sprites = new Set();
const imgCache = new Map();
const audio = { bgm:null, tapGood:null, tapBad:null };

/* ---------------------------
   HELPERS
--------------------------- */
const $ = (sel)=>document.querySelector(sel);
function showScreen(id){
  document.querySelectorAll('.screen').forEach(s=>s.classList.remove('active'));
  $('#'+id).classList.add('active');
}

function preloadImage(path){
  return new Promise(resolve=>{
    const key = ASSET_ROOT + path;
    if(imgCache.has(key)){ resolve(imgCache.get(key)); return; }
    const img = new Image();
    img.onload = ()=>{ const val={ok:true, img}; imgCache.set(key,val); resolve(val); };
    img.onerror = ()=>{ const val={ok:false}; imgCache.set(key,val); resolve(val); };
    img.src = key;
  });
}

async function preloadPool(pool){
  await Promise.all(pool.map(p=>preloadImage(p.src)));
}

function setupAudio(){
  try{ audio.bgm = new Audio(AUDIO.bgm); audio.bgm.loop = true; audio.bgm.volume = 0.35; }catch{}
  try{ audio.tapGood = new Audio(AUDIO.tapGood); audio.tapGood.volume = 0.7; }catch{}
  try{ audio.tapBad  = new Audio(AUDIO.tapBad ); audio.tapBad .volume = 0.6; }catch{}
}
function playSfx(which){
  const el = audio[which];
  if(!el) return;
  try{ el.currentTime = 0; el.play().catch(()=>{}); }catch{}
}

function gridCenters(areaW, areaH){
  const cellW = areaW / GRID_COLS;
  const cellH = areaH / GRID_ROWS;
  const centers = [];
  for(let r=0;r<GRID_ROWS;r++){
    for(let c=0;c<GRID_COLS;c++){
      centers.push({x: c*cellW + cellW/2, y: r*cellH + cellH/2});
    }
  }
  return {centers, cellW, cellH};
}

function nonOverlappingPosition(centers, areaW, areaH){
  for(let attempt=0; attempt<12; attempt++){
    const idx = Math.floor(Math.random()*centers.length);
    const base = centers[idx];
    let x = base.x - SPRITE_SIZE/2 + (Math.random()*2-1)*JITTER;
    let y = base.y - SPRITE_SIZE/2 + (Math.random()*2-1)*JITTER;
    x = Math.max(0, Math.min(areaW - SPRITE_SIZE, x));
    y = Math.max(0, Math.min(areaH - SPRITE_SIZE, y));
    let ok = true;
    for(const s of sprites){
      const dx = (s.x + SPRITE_SIZE/2) - (x + SPRITE_SIZE/2);
      const dy = (s.y + SPRITE_SIZE/2) - (y + SPRITE_SIZE/2);
      const dist = Math.hypot(dx,dy);
      if(dist < SPRITE_SIZE*0.9){ ok = false; break; }
    }
    if(ok) return {x,y};
  }
  return {
    x: Math.random()*(areaW - SPRITE_SIZE),
    y: Math.random()*(areaH - SPRITE_SIZE)
  };
}

function showFeedback(text, good){
  const el = $('#feedback');
  el.textContent = text;
  el.classList.remove('good','bad','show','shake');
  el.classList.add(good ? 'good':'bad', 'show');
  if(!good){ el.classList.add('shake'); }
}

/* ---------------------------
   ROUND MANAGEMENT
--------------------------- */
let currentPool = [];
let playArea, hudTimer, hudScore, hudLevel;

function buildPoolForLevel(lv){
  const items = [];
  lv.positives.forEach(p=>items.push({src:p, positive:true}));
  lv.negatives.forEach(p=>items.push({src:p, positive:false}));
  return items;
}
function buildChaosPool(){
  const items = [];
  LEVELS.forEach(lv=>{
    lv.positives.forEach(p=>items.push({src:p, positive:true}));
    lv.negatives.forEach(p=>items.push({src:p, positive:false}));
  });
  return items;
}

async function startInstruction(){
  if(mode === 'progressive'){
    const lv = LEVELS[levelIndex];
    $('#instrTitle').textContent = lv.title;
    $('#instrText').innerHTML = lv.instruction.replace('positive', '<strong>positive</strong>');
  }else{
    $('#instrTitle').textContent = 'Bonus: Chaos Round';
    $('#instrText').innerHTML = 'All mixed together! Tap only the <strong>positive</strong> items.';
  }
  showScreen('instruction');  // hides launch screen now that #start is not forced display:block
}

async function startRound(){
  playArea = $('#playArea'); hudTimer = $('#hudTimer'); hudScore = $('#hudScore'); hudLevel = $('#hudLevel');
  playArea.style.backgroundImage = `url("${BG_IMAGE}")`;

  currentPool = (mode === 'progressive')
    ? buildPoolForLevel(LEVELS[levelIndex])
    : buildChaosPool();

  await preloadPool(currentPool);
  currentPool = currentPool.filter(p=>{
    const key = ASSET_ROOT + p.src;
    return imgCache.get(key)?.ok;
  });

  if(currentPool.length === 0){
    alert('No images found for this level. Please check assets/attention/ folders.');
    endRound();
    return;
  }

  score = 0;
  hudScore.textContent = 'Score: 0';
  hudLevel.textContent = (mode === 'progressive') ? LEVELS[levelIndex].hud : 'Chaos';
  $('#feedback').classList.remove('good','bad','show','shake');
  showScreen('game');

  try{ audio.bgm && audio.bgm.play().catch(()=>{});}catch{}

  sprites.forEach(s=>s.el.remove());
  sprites.clear();
  roundStart = performance.now();

  const areaRect = playArea.getBoundingClientRect();
  const {centers} = gridCenters(areaRect.width, areaRect.height);

  while(sprites.size < ACTIVE_SPRITES){
    spawnSprite(centers, areaRect.width, areaRect.height);
  }

  let last = performance.now();
  const step = (now)=>{
    rafId = requestAnimationFrame(step);
    const dt = now - last; last = now;
    updateSprites(dt, areaRect.width, areaRect.height);
  };
  rafId = requestAnimationFrame(step);

  timerId = setInterval(()=>{
    const elapsed = performance.now() - roundStart;
    const remain = Math.max(0, ROUND_DURATION_MS - elapsed);
    hudTimer.textContent = Math.ceil(remain/1000) + 's';
    if(remain <= 0){ endRound(); }
  }, 100);
}

function spawnSprite(centers, areaW, areaH){
  if(currentPool.length === 0) return;

  const wantPositive = Math.random() < POSITIVE_SPAWN_RATIO;
  const candidates = currentPool.filter(p=>p.positive === wantPositive);
  const choiceArr = candidates.length ? candidates : currentPool;
  const data = choiceArr[Math.floor(Math.random()*choiceArr.length)];
  const key = ASSET_ROOT + data.src;
  const cached = imgCache.get(key);
  if(!cached?.ok) return;

  const pos = nonOverlappingPosition(centers, areaW, areaH);
  const el = document.createElement('img');
  el.className = 'sprite';
  el.src = key;
  el.style.left = pos.x + 'px';
  el.style.top  = pos.y + 'px';
  el.width = SPRITE_SIZE; el.height = SPRITE_SIZE;

  const record = {
    el,
    positive: data.positive,
    x: pos.x, y: pos.y,
    dx: (Math.random()*40 - 20) / 1000,
    dy: (Math.random()*40 - 20) / 1000,
    born: performance.now(),
    ttl: SPRITE_LIFETIME_MS,
    removed: false
  };

  el.addEventListener('click', (e)=>{
    e.stopPropagation();
    if(record.removed) return;
    if(record.positive){
      score += 1;
      hudScore.textContent = 'Score: ' + score;
      showFeedback('Nice!', true);
      playSfx('tapGood');
      removeSprite(record, true);
    }else{
      showFeedback('Oops – try again', false);
      playSfx('tapBad');
    }
  });

  playArea.appendChild(el);
  sprites.add(record);
}

function updateSprites(dt, areaW, areaH){
  const now = performance.now();

  for(const s of Array.from(sprites)){
    if(s.removed) continue;

    s.x += s.dx * dt * 60/60;
    s.y += s.dy * dt * 60/60;

    if(s.x < 0 || s.x > areaW - SPRITE_SIZE) s.dx *= -1;
    if(s.y < 0 || s.y > areaH - SPRITE_SIZE) s.dy *= -1;
    s.x = Math.max(0, Math.min(areaW - SPRITE_SIZE, s.x));
    s.y = Math.max(0, Math.min(areaH - SPRITE_SIZE, s.y));

    s.el.style.left = s.x + 'px';
    s.el.style.top  = s.y + 'px';

    if(now - s.born > s.ttl){
      removeSprite(s, false);
    }
  }

  while(sprites.size < ACTIVE_SPRITES){
    const areaRect = $('#playArea').getBoundingClientRect();
    const {centers} = gridCenters(areaRect.width, areaRect.height);
    spawnSprite(centers, areaRect.width, areaRect.height);
  }
}

function removeSprite(s, quick){
  if(s.removed) return;
  s.removed = true;
  try{
    if(!quick) s.el.classList.add('fade-out');
    setTimeout(()=>{ s.el.remove(); sprites.delete(s); }, quick ? 0 : 700);
  }catch{
    s.el.remove(); sprites.delete(s);
  }
}

function endRound(){
  if(rafId){ cancelAnimationFrame(rafId); rafId = null; }
  if(timerId){ clearInterval(timerId); timerId = null; }
  sprites.forEach(s=>s.el.remove()); sprites.clear();
  $('#finalScore').textContent = `You scored ${score} points.`;
  const nextBtn = $('#btnPlayNext');
  if(mode === 'progressive' && levelIndex < LEVELS.length - 1){
    nextBtn.textContent = 'Next Level';
  }else if(mode === 'progressive' && levelIndex === LEVELS.length - 1){
    mode = 'chaos'; nextBtn.textContent = 'Chaos Round';
  }else{
    nextBtn.textContent = 'Back to Start';
  }
  showScreen('end');
}

/* ---------------------------
   EVENT WIRING
--------------------------- */
function wireUI(){
  // Preserve original hidden controls & logic
  $('#btnStartProgressive').addEventListener('click', ()=>{
    mode = 'progressive'; levelIndex = 0; startInstruction();
    try{ if(!audio.bgm) setupAudio(); }catch{}
  });
  $('#btnChaos').addEventListener('click', ()=>{
    mode = 'chaos'; startInstruction();
    try{ if(!audio.bgm) setupAudio(); }catch{}
  });

  // Visible launch controls mapping to preserved logic
  $('#launchStart').addEventListener('click', ()=>{
    document.getElementById('btnStartProgressive').click();
  });

  // --- Launch: How to Play should toggle panel on the launch screen ---
  const howToBtn = document.getElementById('launchHowTo');
  const howToPanel = document.getElementById('howToPanel');
  howToBtn.addEventListener('click', ()=>{
    if(!howToPanel) return;
    howToPanel.classList.toggle('hidden');
  });
  // Optional: hide the panel when Start is pressed (keeps UX tidy)
  const launchStartBtn = document.getElementById('launchStart');
  if(launchStartBtn && howToPanel){
    launchStartBtn.addEventListener('click', ()=> howToPanel.classList.add('hidden'));
  }

  $('#btnBeginRound').addEventListener('click', ()=>{
    startRound();
    try{ if(!audio.bgm) setupAudio(); audio.bgm && audio.bgm.play().catch(()=>{});}catch{}
  });

  $('#btnReplay').addEventListener('click', ()=>{
    startInstruction();
  });

  $('#btnPlayNext').addEventListener('click', ()=>{
    if(mode === 'progressive' && levelIndex < LEVELS.length - 1){
      levelIndex += 1; startInstruction();
    }else if(mode === 'progressive' && levelIndex === LEVELS.length - 1){
      mode = 'chaos'; startInstruction();
    }else{
      showScreen('start');
    }
  });

  // Prevent text selection on rapid taps (kept from original)
  document.addEventListener('mousedown', (e)=>{ e.preventDefault(); }, {passive:false});
}

document.addEventListener('DOMContentLoaded', ()=>{
  wireUI();
  setupAudio();
});
</script>

</body>
</html>
